ðŸ“± DÃ‰MARRAGE RAPIDISSIME - Dual Database (SQLite + MySQL)
========================================================

VERSION ULTRA-RAPIDE (2 MINUTES)
================================

Ã‰tape 1: INSTALLER
   $ python setup_dual_system.py --quick

Ã‰tape 2: CONFIGURER MYSQL
   $ cd app
   $ python mysql_config_setup.py --all
   
   RÃ©pondre aux questions:
   - Host: localhost
   - Port: 3306
   - User: epi_user
   - Password: [votre mot de passe]
   - Database: epi_detection_db

Ã‰tape 3: VÃ‰RIFIER
   $ python sync_databases.py --status

Ã‰tape 4: LANCER SYNC
   $ python sync_databases.py --watch

Ã‰tape 5: APP (autre terminal)
   $ cd ..
   $ python run_app.py

âœ… FINI! SQLite + MySQL tournent ensemble!


VERSION AVEC DÃ‰TAILS (5 MINUTES)
================================

1) INSTALLER LES DÃ‰PENDANCES
   $ python install_mysql_requirements.py

2) CRÃ‰ER LES RÃ‰PERTOIRES
   $ mkdir -p database logs instance

3) CONFIGURER .env
   CrÃ©er fichier .env Ã  la racine:
   
   DUAL_DATABASE=true
   SYNC_MODE=sqlite_primary
   DB_HOST=localhost
   DB_PORT=3306
   DB_USER=epi_user
   DB_PASSWORD=votre_mot_de_passe
   DB_NAME=epi_detection_db
   SQLALCHEMY_ECHO=false

4) CONFIGURER MYSQL
   $ cd app
   $ python mysql_config_setup.py --interactive
   
   OU avec PHPMyAdmin:
   - Aller Ã  http://localhost/phpmyadmin
   - CrÃ©er base: epi_detection_db
   - Charset: utf8mb4

5) IMPORTER LE SCHÃ‰MA
   $ python mysql_config_setup.py --import-schema ../database/epi_detection_mysql_schema.sql
   
   OU via PHPMyAdmin:
   - Aller Ã  base epi_detection_db â†’ SQL
   - Importer: database/epi_detection_mysql_schema.sql

6) VÃ‰RIFIER LA CONNEXION
   $ python sync_databases.py --status
   
   Vous devriez voir:
   âœ“ SQLite: ...
   âœ“ MySQL: ...

7) LANCER LA SYNCHRONISATION
   $ python sync_databases.py --watch
   
   Vous devriez voir:
   [1] âœ“ SQLiteâ†’MySQL synced
   [2] âœ“ MySQLâ†’SQLite synced
   ...

8) DÃ‰MARRER L'APP (autre terminal)
   $ cd ..
   $ python run_app.py

9) TESTER
   - App: http://localhost:5000
   - PHPMyAdmin: http://localhost/phpmyadmin


COMMANDES UTILES
================

VOIR LE STATUT
   $ python sync_databases.py --status

SYNCHRONISER MANUELLEMENT
   $ python sync_databases.py --sync-sqlite    # SQLite â†’ MySQL
   $ python sync_databases.py --sync-mysql     # MySQL â†’ SQLite

VÃ‰RIFIER LA SANTÃ‰
   $ python database_manager.py --health

COMPARER LES BASES
   $ python database_manager.py --compare

EXPORTER STATUT
   $ python database_manager.py --export status.json

DAEMON (ARRIÃˆRE-PLAN)
   $ python sync_databases.py --daemon &


FICHIERS IMPORTANTS
===================

Configuration:
  - .env                    Configuration (ne pas commiter!)
  - config.py              Configuration Flask (auto-dÃ©tecte dual-db)

Base de donnÃ©es:
  - app/dual_database.py   Moteur dual-database
  - app/sync_databases.py  Synchroniseur
  - database/epi_detection_mysql_schema.sql  SchÃ©ma MySQL

Documentation:
  - GUIDE_DUAL_DATABASE.md       Concept & usage
  - GUIDE_MIGRATION_MYSQL.md     Migration donnÃ©es
  - DUAL_DATABASE_SUMMARY.txt    RÃ©sumÃ© technique

Logs:
  - logs/app.log           Logs application
  - logs/sync.log          Logs synchronisation
  - logs/error.log         Erreurs


MODE DE SYNC
============

Par dÃ©faut: SYNC_MODE=sqlite_primary

Signifie:
  1. DonnÃ©es Ã©crites dans SQLite (rapide âš¡)
  2. App retourne immÃ©diatement
  3. Background: sync SQLite â†’ MySQL

Alternative: SYNC_MODE=mysql_primary
  1. DonnÃ©es Ã©crites dans MySQL (safe âœ…)
  2. Background: sync MySQL â†’ SQLite

Ã‰diter .env pour changer:
  SYNC_MODE=mysql_primary


DÃ‰PANNAGE RAPIDE
================

âŒ "MySQL not connected"
   â†’ VÃ©rifier MySQL en cours: mysql -u root -p
   â†’ VÃ©rifier .env: DB_HOST, DB_USER, DB_PASSWORD
   â†’ Tester: cd app && python mysql_config_setup.py --verify

âŒ "Tables don't exist"
   â†’ Importer le schÃ©ma:
      cd app
      python mysql_config_setup.py --import-schema ../database/epi_detection_mysql_schema.sql

âŒ "Sync failing"
   â†’ VÃ©rifier les logs: tail -f logs/sync.log
   â†’ VÃ©rifier santÃ©: python database_manager.py --health

âŒ "Database locked" (SQLite)
   â†’ Fermer l'app et relancer
   â†’ Ou: sqlite3 instance/epi_detection.db "VACUUM;"


NOTES IMPORTANTES
=================

âœ… .env ne doit JAMAIS Ãªtre committÃ©:
   - Ajouter au .gitignore
   - Contient le mot de passe MySQL

âœ… Sauvegarder MySQL rÃ©guliÃ¨rement:
   $ mysqldump -u epi_user -p epi_detection_db > backup.sql

âœ… Les deux bases restent synchronisÃ©es:
   - SQLite pour cache local rapide
   - MySQL pour stockage central sÃ»r
   - Parfait pour dev ET production!

âœ… Si MySQL tombe:
   - L'app continue Ã  fonctionner avec SQLite
   - Quand MySQL revient: sync automatique
   - ZÃ©ro downtime!


POUR LA PRODUCTION
==================

Changer .env:
   DUAL_DATABASE=true
   SYNC_MODE=mysql_primary        (prioritÃ© MySQL)
   DB_HOST=ip_serveur             (serveur distant)
   SQLALCHEMY_ECHO=false          (sans debug)
   DEBUG=false

Lancer en daemon:
   python sync_databases.py --daemon &

Monitorer:
   tail -f logs/sync.log
   python sync_databases.py --status

Lancer app avec Gunicorn:
   gunicorn --workers 4 --bind 0.0.0.0:5000 app:app


RESSOURCES
==========

Documentation:
   - GUIDE_DUAL_DATABASE.md        Guide complet
   - GUIDE_MIGRATION_MYSQL.md      Migration SQLiteâ†’MySQL
   - Code comments                 Explications dÃ©taillÃ©es

Support:
   - VÃ©rifier les logs: logs/
   - ExÃ©cuter diagnostique: python database_manager.py --health
   - Lire le guide: GUIDE_DUAL_DATABASE.md


BESOIN D'AIDE?
==============

ProblÃ¨me avec setup?
   â†’ python setup_dual_system.py --verify

ProblÃ¨me avec MySQL?
   â†’ python mysql_config_setup.py --verify

ProblÃ¨me avec sync?
   â†’ python sync_databases.py --status
   â†’ python database_manager.py --health

ProblÃ¨me application?
   â†’ tail -f logs/app.log
   â†’ tail -f logs/error.log


C'EST PRÃŠT! ðŸš€
==============

Vous avez maintenant:
  âœ… SQLite: Cache local rapide (instance/epi_detection.db)
  âœ… MySQL: Stockage central sÃ»r (serveur MySQL)
  âœ… Sync: Automatique continu
  âœ… Failover: Automatique si MySQL tombe
  âœ… Zero downtime: L'app continue sur SQLite

C'est professionnel et prÃªt pour la production!

DÃ©marrage:
   1. python setup_dual_system.py --quick
   2. cd app && python mysql_config_setup.py --all
   3. python sync_databases.py --watch
   4. python run_app.py (autre terminal)

VoilÃ ! ðŸŽ‰
